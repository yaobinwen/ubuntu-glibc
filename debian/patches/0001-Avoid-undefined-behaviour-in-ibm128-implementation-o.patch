From b663afa6de87903d38b06d7317df2c02f67197a4 Mon Sep 17 00:00:00 2001
From: Michael Hudson-Doyle <michael.hudson@canonical.com>
Date: Sun, 21 Aug 2022 22:33:02 +1200
Subject: [PATCH] Avoid undefined behaviour in ibm128 implementation of
 llroundl

Detecting an overflow edge case depended on signed overflow of a long
long. Replace the signed long long with unsigned and cast it back to
unsigned before comparisons (which is implementation defined behaviour,
but I guess glibc does not support any one's complement
architectures...).

BZ #29488
---
 sysdeps/ieee754/ldbl-128ibm/s_llroundl.c | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/sysdeps/ieee754/ldbl-128ibm/s_llroundl.c b/sysdeps/ieee754/ldbl-128ibm/s_llroundl.c
index d85154e73a..5f54f92767 100644
--- a/sysdeps/ieee754/ldbl-128ibm/s_llroundl.c
+++ b/sysdeps/ieee754/ldbl-128ibm/s_llroundl.c
@@ -28,7 +28,8 @@ long long
 __llroundl (long double x)
 {
   double xh, xl;
-  long long res, hi, lo;
+  unsigned long long res;
+  long long hi, lo;
 
   ldbl_unpack (x, &xh, &xl);
 
@@ -69,7 +70,7 @@ __llroundl (long double x)
       res = hi + lo;
 
       /* This is just sign(hi) == sign(lo) && sign(res) != sign(hi).  */
-      if (__glibc_unlikely (((~(hi ^ lo) & (res ^ hi)) < 0)))
+      if (__glibc_unlikely (((~(hi ^ lo) & (((long long)res) ^ hi)) < 0)))
 	goto overflow;
 
       xh -= lo;
@@ -82,7 +83,7 @@ __llroundl (long double x)
 	}
       else if (xh == 0.5)
 	{
-	  if (xl > 0.0 || (xl == 0.0 && res >= 0))
+	  if (xl > 0.0 || (xl == 0.0 && ((long long)res) >= 0))
 	    res += 1;
 	}
       else if (-xh > 0.5)
@@ -91,11 +92,11 @@ __llroundl (long double x)
 	}
       else if (-xh == 0.5)
 	{
-	  if (xl < 0.0 || (xl == 0.0 && res <= 0))
+	  if (xl < 0.0 || (xl == 0.0 && ((long long)res) <= 0))
 	    res -= 1;
 	}
 
-      if (__glibc_unlikely (((~(hi ^ (res - hi)) & (res ^ hi)) < 0)))
+      if (__glibc_unlikely (((~(hi ^ (((long long)res) - hi)) & (((long long)res) ^ hi)) < 0)))
 	goto overflow;
 
       return res;
-- 
2.34.1

