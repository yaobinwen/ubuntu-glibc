Committed for 2.33

commit f6abd970284a06380cd9d905f43da104bd49fc95
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Dec 28 23:37:04 2020 +0100

    hurd: Add WSTOPPED/WCONTINUED/WEXITED/WNOWAIT support [BZ #23091]
    
    The new __proc_waitid RPC now expects WEXITED to be passed, allowing to
    properly implement waitid, and thus define the missing W* macros
    (according to FreeBSD values).

---
 bits/waitflags.h             |    8 ++++++++
 conform/data/sys/wait.h-data |   12 +++++-------
 sysdeps/mach/hurd/waitid.c   |   41 +++++++++++++++++++++++++++++++----------
 3 files changed, 44 insertions(+), 17 deletions(-)

--- a/bits/waitflags.h
+++ b/bits/waitflags.h
@@ -24,3 +24,11 @@
 /* Bits in the third argument to `waitpid'.  */
 #define	WNOHANG		1	/* Don't block waiting.  */
 #define	WUNTRACED	2	/* Report status of stopped children.  */
+
+/* Bits in the fourth argument to `waitid'.  */
+#if defined __USE_XOPEN_EXTENDED || defined __USE_XOPEN2K8
+# define WSTOPPED	WUNTRACED	/* Report stopped child. */
+# define WCONTINUED	4		/* Report continued child.  */
+# define WNOWAIT	8		/* Don't reap, just poll status.  */
+# define WEXITED	16		/* Report dead child.  */
+#endif
--- a/conform/data/sys/wait.h-data
+++ b/conform/data/sys/wait.h-data
@@ -8,8 +8,7 @@
 
 macro WEXITSTATUS
 # if !defined XPG4 && !defined POSIX && !defined POSIX2008
-// Bug 23091: hurd: missing waitid support.
-xfail[i386-gnu]-macro WIFCONTINUED
+macro WIFCONTINUED
 # endif
 macro WIFEXITED
 macro WIFSIGNALED
@@ -17,15 +16,14 @@
 macro WSTOPSIG
 macro WTERMSIG
 
-// Bug 23091: hurd: missing waitid support.
 # if !defined XPG4 && !defined POSIX
-xfail[i386-gnu]-constant WEXITED
-xfail[i386-gnu]-constant WSTOPPED
+constant WEXITED
+constant WSTOPPED
 #  ifndef POSIX2008
-xfail[i386-gnu]-constant WCONTINUED
+constant WCONTINUED
 #  endif
 constant WNOHANG
-xfail[i386-gnu]-constant WNOWAIT
+constant WNOWAIT
 # endif
 
 #if !defined XPG4 && !defined POSIX
--- a/sysdeps/mach/hurd/waitid.c
+++ b/sysdeps/mach/hurd/waitid.c
@@ -1,4 +1,4 @@
-/* Pseudo implementation of waitid.
+/* Implementation of waitid.  Hurd version.
    Copyright (C) 1997-2020 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Zack Weinberg <zack@rabi.phys.columbia.edu>, 1997.
@@ -18,13 +18,23 @@
    <https://www.gnu.org/licenses/>.  */
 
 #include <errno.h>
+#include <sys/types.h>
 #include <sys/wait.h>
+#include <stddef.h>
+#include <hurd.h>
+#include <hurd/port.h>
+#include <hurd/version.h>
+#include <sysdep-cancel.h>
 
 int
 __waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options)
 {
+  struct rusage ignored;
+  error_t err;
   pid_t pid, child;
+  int sigcode;
   int status;
+  int cancel_oldtype;
 
   switch (idtype)
     {
@@ -58,16 +68,19 @@
       return -1;
     }
 
-  /* Note the waitid() is a cancellation point.  But since we call
-     waitpid() which itself is a cancellation point we do not have
-     to do anything here.  */
-  child = __waitpid (pid, &status, options);
-
-  if (child == -1)
-    /* `waitpid' set `errno' for us.  */
-    return -1;
+  cancel_oldtype = LIBC_CANCEL_ASYNC();
+#if HURD_INTERFACE_VERSION >= 20201227
+  err = __USEPORT_CANCEL (PROC, __proc_waitid (port, pid, options,
+					       &status, &sigcode,
+					       &ignored, &child));
+  if (err == MIG_BAD_ID || err == EOPNOTSUPP)
+#endif
+    err = __USEPORT_CANCEL (PROC, __proc_wait (port, pid, options,
+					       &status, &sigcode,
+					       &ignored, &child));
+  LIBC_CANCEL_RESET (cancel_oldtype);
 
-  if (child == 0)
+  if (err == EAGAIN)
     {
       /* POSIX.1-2008, Technical Corrigendum 1 XSH/TC1-2008/0713 [153] states
 	 that if waitid returns because WNOHANG was specified and status is
@@ -79,6 +92,9 @@
       return 0;
     }
 
+  if (err != 0)
+    return __hurd_fail (err);
+
   /* Decode the status field and set infop members... */
   infop->si_signo = SIGCHLD;
   infop->si_pid = child;
@@ -99,6 +115,11 @@
       infop->si_code = CLD_STOPPED;
       infop->si_status = WSTOPSIG (status);
     }
+  else if (WIFCONTINUED (status))
+    {
+      infop->si_code = CLD_CONTINUED;
+      infop->si_status = SIGCONT;
+    }
 
   return 0;
 }
