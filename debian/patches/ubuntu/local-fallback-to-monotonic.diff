From 82bf350c637bac82220435c25d1504889206e67f Mon Sep 17 00:00:00 2001
From: Balint Reczey <balint.reczey@canonical.com>
Date: Mon, 27 Jul 2020 18:44:40 +0200
Subject: [PATCH] Fall back to CLOCK_MONOTONIC when clock_nanosleep_time64 with
 CLOCK_REALTIME fails

Based on Christian Pfeiffer's patch at
https://gist.github.com/ChrisTX/391fe201b3d72d3b3dac17066100347d

See: https://github.com/microsoft/WSL/issues/4898
---
 sysdeps/unix/sysv/linux/clock_nanosleep.c | 31 +++++++++++++++++++++++
 1 file changed, 31 insertions(+)

diff --git a/sysdeps/unix/sysv/linux/clock_nanosleep.c b/sysdeps/unix/sysv/linux/clock_nanosleep.c
index 728137aa56..a101c32936 100644
--- a/sysdeps/unix/sysv/linux/clock_nanosleep.c
+++ b/sysdeps/unix/sysv/linux/clock_nanosleep.c
@@ -24,6 +24,31 @@
 
 #include <shlib-compat.h>
 
+/* Use CLOCK_MONOTONIC and convert request with TIMER_ABSTIME to use relative time */
+#define MONOTONIC_FALLBACK do {                                         \
+    if (__glibc_unlikely (flags & TIMER_ABSTIME))                       \
+    {                                                                   \
+      struct __timespec64 current_realtime, actual_req;                 \
+      actual_req = *req;                                                \
+      if(__clock_gettime64(CLOCK_REALTIME, &current_realtime))          \
+        return EINVAL;                                                  \
+      actual_req.tv_nsec -= current_realtime.tv_nsec;                   \
+      actual_req.tv_sec -= current_realtime.tv_sec;                     \
+      if(actual_req.tv_nsec < 0)                                        \
+      {                                                                 \
+        --actual_req.tv_sec;                                            \
+        actual_req.tv_nsec = 1000000000L - actual_req.tv_nsec;          \
+      }                                                                 \
+      flags = flags & ~TIMER_ABSTIME;                                   \
+      r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64,              \
+                                   err, CLOCK_MONOTONIC, flags,         \
+                                   &actual_req, rem);                   \
+    }                                                                   \
+    r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64,                \
+                                 err, CLOCK_MONOTONIC, flags,           \
+                                 req, rem);                             \
+  } while (0)
+
 /* We can simply use the syscall.  The CPU clocks are not supported
    with this function.  */
 int
@@ -47,10 +72,16 @@ __clock_nanosleep_time64 (clockid_t clock_id, int flags, const struct __timespec
 # endif
   r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, err, clock_id,
                                flags, req, rem);
+  if (__glibc_unlikely (INTERNAL_SYSCALL_ERRNO (r, err) == EINVAL
+                        && clock_id == CLOCK_REALTIME))
+    MONOTONIC_FALLBACK;
 #else
 # ifdef __NR_clock_nanosleep_time64
   r = INTERNAL_SYSCALL_CANCEL (clock_nanosleep_time64, err, clock_id,
                                flags, req, rem);
+  if (__glibc_unlikely (INTERNAL_SYSCALL_ERRNO (r, err) == EINVAL
+                        && clock_id == CLOCK_REALTIME))
+    MONOTONIC_FALLBACK;
 
   if (! INTERNAL_SYSCALL_ERROR_P (r, err))
     return 0;
-- 
2.25.1

